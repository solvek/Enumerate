// Generated by CoffeeScript 1.6.1
(function() {
  var Analyze, Average, Engine, engine,
    __slice = [].slice;

  Analyze = {
    UNDEFINED: 0,
    SUCCESS: 1,
    FAIL: -1
  };

  Average = (function() {

    function Average() {
      this.value = 0.0;
      this.count = 0;
    }

    Average.prototype.add = function(val) {
      var next;
      next = this.count + 1;
      this.value *= this.count / next;
      this.value += val / next;
      return this.count = next;
    };

    return Average;

  })();

  Engine = (function() {

    function Engine() {}

    Engine.prototype.start = function(options) {
      this._options = options;
      this.reset();
      return this.execute();
    };

    Engine.prototype.reset = function() {
      this.values = [];
      this.size = 0;
      this.status = Analyze.UNDEFINED;
      return this._lastTicks = -1;
    };

    Engine.prototype.execute = function() {
      var enumerator, last, value, _ref;
      while (true) {
        this.status = this.analyze();
        if (this.status === Analyze.SUCCESS) {
          this.trigger('onSolution', this.pureValues());
          if (!this._options.all) {
            break;
          }
        }
        if (this.status !== Analyze.FAIL) {
          enumerator = this.nextEnumerator();
          if (enumerator) {
            value = (_ref = this.values[this.size]) != null ? _ref : {
              avr: new Average
            };
            value.raw = 0;
            value.enumerator = enumerator;
            value.avr.add(enumerator.count);
            this.addValue(value);
            continue;
          }
        }
        while (this.size > 0) {
          last = this.values[this.size - 1];
          if (this.onStateRemove) {
            this.onStateRemove(last);
          }
          this.size--;
          if (last.raw < last.enumerator.count - 1) {
            last.raw++;
            this.addValue(last);
            break;
          }
        }
        if (this.size === 0) {
          break;
        }
      }
      return this.trigger('onComplete');
    };

    Engine.prototype.addValue = function(value) {
      var ticksPerOne;
      value.value = value.enumerator.toValue(value.raw);
      ticksPerOne = this.size === 0 ? this._options.ticks : this.values[this.size - 1].ticksPerOne;
      value.ticksPerOne = ticksPerOne / value.avr.value;
      value.ticks = (this.size === 0 ? 0 : this.values[this.size - 1].ticks) + Math.floor(value.ticksPerOne * value.raw);
      if (value.ticks > this._lastTicks) {
        this.trigger('onProgress', value.ticks, this.pureValues());
        this._lastTicks = value.ticks;
      }
      if (this.onStateAdd) {
        this.onStateAdd(value);
      }
      return this.values[this.size++] = value;
    };

    Engine.prototype.trigger = function() {
      var args, method;
      method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return postMessage(JSON.stringify({
        method: method,
        args: args
      }));
    };

    Engine.prototype.pureValues = function() {
      return this.values.map(function(item) {
        return item.enumerator.toString(item.value, item.raw);
      });
    };

    Engine.queenPosition = {
      count: 64,
      toValue: function(row) {
        return {
          x: Math.floor(row / 8),
          y: row % 8
        };
      },
      toString: function(value) {
        return "(" + (String.fromCharCode(65 + value.x)) + (1 + value.y) + ")";
      }
    };

    Engine.prototype.nextEnumerator = function() {
      if (this.size < 8) {
        return Engine.queenPosition;
      }
    };

    Engine.prototype.analyze = function() {
      if (this.isConflicted) {
        return Analyze.FAIL;
      } else {
        if (this.size < 8) {
          return Analyze.UNDEFINED;
        } else {
          return Analyze.SUCCESS;
        }
      }
    };

    Engine.prototype.onStateRemove = function() {
      return this.isConflicted = false;
    };

    Engine.prototype.onStateAdd = function(state) {
      var difx, dify, idx, other, _i, _ref;
      for (idx = _i = 0, _ref = this.size; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
        other = this.values[idx];
        difx = state.value.x - other.value.x;
        dify = state.value.y - other.value.y;
        if (state.value.x === other.value.x || state.value.y === other.value.y || difx === dify || difx === -dify) {
          this.isConflicted = true;
          return;
        }
      }
    };

    return Engine;

  })();

  engine = new Engine();

  addEventListener('message', function(event) {
    var message;
    message = JSON.parse(event.data);
    return engine[message.method].apply(engine, message.args);
  });

}).call(this);
